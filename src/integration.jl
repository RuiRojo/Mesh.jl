using StaticArrays

module Integration

using StaticArrays: SVector
using LinearAlgebra

export QuadratureRule, integrate_triangle
export @quad_gquts, @quad_gqutm, quad_gquts, quad_gqutm
export Quad7, Quad21, Quad44, Quad65

import ..AbstractMesh

const Float = Float64 #Float32
const Vec = SVector
const Point2 = SVector{2, Float}

struct QuadratureRule{N}
    points  :: Vec{N, Point2}
    weights :: Vec{N, Float}
end
QuadratureRule(w, x, y) = QuadratureRule(Point2.(x, y), w)
QuadratureRule(pts :: Vector, ws :: Vector) = 
    QuadratureRule(
                   map(Point2, Vec(pts...) ), 
                   Vec(ws...))

# Quadrature rule for P outside the element
const Quad7 = let
    WQ = [ 0.225000000000000; 0.125939180544827; 0.125939180544827; 0.125939180544827;
        0.132394152788506; 0.132394152788506; 0.132394152788506 ] ;
    XQ = [ 0.333333333333333; 0.797426985353087; 0.101286507323456; 0.101286507323456;
        0.470142064105115; 0.470142064105115; 0.059715871789770 ] ;
    YQ = [ 0.333333333333333; 0.101286507323456; 0.797426985353087; 0.101286507323456;
        0.470142064105115; 0.059715871789770; 0.470142064105115 ] ; 
    wq = convert.(Float, WQ)
    xq = convert.(Float, XQ)
    yq = convert.(Float, YQ)
    
    QuadratureRule(zip(xq, yq) |> collect, wq)
end 
# Función que da una regla de cuadratura de 21 puntos a partir de la de 7
# Es para triángulos donde el punto es parte del panel
# Toma 'NQ' nro de puntos de la regla original, 'XQOFF', 'YQOFF' abscisas y ordenadas
# de la regla original y los pesos 'WQOFF'
function glt7x3( quadOff :: QuadratureRule )

    WQOFF::Vector{Float}, XQOFF::Vector{Float}, YQOFF::Vector{Float} = 
        quadOff.weights, map(first, quadOff.points), map(last, quadOff.points)

    NQOFF = length(quadOff.weights)

    XQON = zeros( Float64, 3*NQOFF ) ; # x-Abscissae of the actual quadrature rule
    YQON = zeros( Float64, 3*NQOFF ) ; # y-Abscissae of the actual quadrature rule
    WQON = zeros( Float64, 3*NQOFF ) ; # Weights of the actual quadrature rule
    for IQ = 1 : NQOFF 
        XQON[ IQ ] = XQOFF[ IQ ]/3 + YQOFF[ IQ ] ;
        YQON[ IQ ] = XQOFF[ IQ ]/3 ;
        WQON[ IQ ] = WQOFF[ IQ ]/3 ;
        XQON[ IQ + NQOFF ] = XQOFF[ IQ ]/3 ;
        YQON[ IQ + NQOFF ] = XQOFF[ IQ ]/3 + YQOFF[ IQ ] ;
        WQON[ IQ + NQOFF ] = WQOFF[ IQ ]/3 ;
        XQON[ IQ + 2*NQOFF ] = ( 1/3 )*( 1.0 + 2*XQOFF[ IQ ]- YQOFF[ IQ ] ) ;
        YQON[ IQ + 2*NQOFF ] = ( 1/3 )*( 1.0 - XQOFF[ IQ ] + 2*YQOFF[ IQ ] ) ;
        WQON[ IQ + 2*NQOFF ] = WQOFF[IQ]/3 ;
    end 
    xqon = convert.(Float, XQON)
    yqon = convert.(Float, YQON)
    wqon = convert.(Float, WQON)
    return QuadratureRule(zip(xqon, yqon) |> collect, wqon); 
end

const Quad44 = let
	mat = [ 0.019855071751231912	0.015603789881627896	0.004031966995326902
			0.019855071751231912	0.08035663927218227	0.00896183208968381
			0.019855071751231912	0.18947601467730188	0.0129287189692663
			0.019855071751231912	0.33116478991611215	0.015495325539817254
			0.019855071751231912	0.49007246412438404	0.016382949250869517
			0.019855071751231912	0.648980138332656	0.015495325539817254
			0.019855071751231912	0.7906689135714662	0.0129287189692663
			0.019855071751231912	0.8997882889765858	0.00896183208968381
			0.019855071751231912	0.9645411383671402	0.004031966995326902
			0.10166676129318664	0.017836470911040323	0.010111327490140942
			0.10166676129318664	0.09133063094134085	0.022212782574513718
			0.10166676129318664	0.21311500343064044	0.031334945150309046
			0.10166676129318664	0.3667739011113349	0.036227082238771975
			0.10166676129318664	0.5315593375954785	0.036227082238771975
			0.10166676129318664	0.6852182352761729	0.031334945150309046
			0.10166676129318664	0.8070026077654725	0.022212782574513718
			0.10166676129318664	0.880496767795773	0.010111327490140942
			0.2372337950418355	0.019409382282356176	0.015491893912735213
			0.2372337950418355	0.09857563833019303	0.033464628211129784
			0.2372337950418355	0.22660061952067778	0.045683068931764194
			0.2372337950418355	0.38138310247908225	0.0500056456351725
			0.2372337950418355	0.5361655854374867	0.045683068931764194
			0.2372337950418355	0.6641905666279715	0.033464628211129784
			0.2372337950418355	0.7433568226758083	0.015491893912735213
			0.4082826787521751	0.01997947907913758	0.018383655713702835
			0.4082826787521751	0.10023413715204454	0.0387108489950919
			0.4082826787521751	0.2252611078301697	0.05020863367154068
			0.4082826787521751	0.3664562134176553	0.05020863367154068
			0.4082826787521751	0.4914831840957804	0.0387108489950919
			0.4082826787521751	0.5717378421686874	0.018383655713702835
			0.591717321247825	0.01915257191055202	0.0175417711949084
			0.591717321247825	0.09421749319819557	0.035437070061643344
			0.591717321247825	0.20414133937608755	0.04211982410458773
			0.591717321247825	0.3140651855539795	0.035437070061643344
			0.591717321247825	0.3891301068416231	0.0175417711949084
			0.7627662049581645	0.01647157989702492	0.012943995010482759
			0.7627662049581645	0.07828940091495819	0.024266914055245434
			0.7627662049581645	0.15894439412687733	0.024266914055245434
			0.7627662049581645	0.22076221514481056	0.012943995010482759
			0.8983332387068134	0.01145801331145765	0.006280210984973098
			0.8983332387068134	0.05083338064659332	0.010048337575956955
			0.8983332387068134	0.09020874798172898	0.006280210984973098
			0.9801449282487681	0.004195870365439416	0.0010049499256587963
			0.9801449282487681	0.015659201385792496	0.0010049499256587963 ]
    QuadratureRule(
        SVector{44, Point2}([ Point2(pt) for pt in eachrow(mat[:, 1:2]) ]), 
        SVector{44, Float}(mat[:, 3])
        )
end

const Quad65 = let 
    mat = [ 0.013046735741414128	0.010743648455019322	0.0018315376345417456
        0.013046735741414128	0.05573196790787835	0.004131688397056032
        0.013046735741414128	0.13316367947616234	0.0061290877408219655
        0.013046735741414128	0.23731482253696315	0.0076722498551001885
        0.013046735741414128	0.360463383316429	0.008646466735790522
        0.013046735741414128	0.49347663212929294	0.008979440171346999
        0.013046735741414128	0.6264898809421569	0.008646466735790522
        0.013046735741414128	0.7496384417216226	0.0076722498551001885
        0.013046735741414128	0.8537895847824235	0.0061290877408219655
        0.013046735741414128	0.9312212963507076	0.004131688397056032
        0.013046735741414128	0.9762096158035665	0.0018315376345417456
        0.06746831665550773	0.012166494443091671	0.004645929897132954
        0.06746831665550773	0.06291634290317988	0.010414376646895578
        0.06746831665550773	0.14948036746912413	0.01526682703373161
        0.06746831665550773	0.2641883734516979	0.018763597982262337
        0.06746831665550773	0.39685082270357663	0.020593327540725605
        0.06746831665550773	0.5356808606409157	0.020593327540725605
        0.06746831665550773	0.6683433098927944	0.018763597982262337
        0.06746831665550773	0.7830513158753682	0.01526682703373161
        0.06746831665550773	0.8696153404413125	0.010414376646895578
        0.06746831665550773	0.9203651889014006	0.004645929897132954
        0.16029521585048778	0.013367999605810503	0.007475937924006081
        0.16029521585048778	0.06884273181476093	0.016616728377363568
        0.16029521585048778	0.16232692882509292	0.023971996934294904
        0.16029521585048778	0.2837138166202382	0.028730912723790195
        0.16029521585048778	0.4198523920747561	0.030376714827674876
        0.16029521585048778	0.555990967529274	0.028730912723790195
        0.16029521585048778	0.6773778553244193	0.023971996934294904
        0.16029521585048778	0.7708620523347512	0.016616728377363568
        0.16029521585048778	0.8263367845437017	0.007475937924006081
        0.2833023029353764	0.014230084199160775	0.009767685091002417
        0.2833023029353764	0.07286433368684568	0.021457861531466595
        0.2833023029353764	0.17002491457238442	0.030269999351765227
        0.2833023029353764	0.29261525561305946	0.034995872838576136
        0.2833023029353764	0.4240824414515642	0.034995872838576136
        0.2833023029353764	0.5466727824922392	0.030269999351765227
        0.2833023029353764	0.643833363377778	0.021457861531466595
        0.2833023029353764	0.7024676128654629	0.009767685091002417
        0.4255628305091844	0.014617153391652144	0.010990690348350176
        0.4255628305091844	0.0742370470729654	0.023741407497558403
        0.4255628305091844	0.170652314741006	0.0324097536182204
        0.4255628305091844	0.2872185847454078	0.03547639623285247
        0.4255628305091844	0.4037848547498096	0.0324097536182204
        0.4255628305091844	0.5002001224178502	0.023741407497558403
        0.4255628305091844	0.5598200160991634	0.010990690348350176
        0.5744371694908156	0.014369232340683444	0.010773237484994033
        0.5744371694908156	0.07208834622267984	0.022685431883877852
        0.5744371694908156	0.1620076871329107	0.029423393407949416
        0.5744371694908156	0.2635551433762738	0.029423393407949416
        0.5744371694908156	0.3534744842865046	0.022685431883877852
        0.5744371694908156	0.411193598168501	0.010773237484994033
        0.7166976970646236	0.013289732853664154	0.009036851233736988
        0.7166976970646236	0.06537635366120652	0.018255826435561825
        0.7166976970646236	0.1416511514676882	0.02169852634577794
        0.7166976970646236	0.21792594927416986	0.018255826435561825
        0.7166976970646236	0.2700125700817122	0.009036851233736988
        0.8397047841495122	0.01112959245341311	0.0061080694536620565
        0.8397047841495122	0.05289894054198958	0.01145117843103672
        0.8397047841495122	0.1073962753084982	0.01145117843103672
        0.8397047841495122	0.14916562339707468	0.0061080694536620565
        0.9325316833444923	0.007603791647410872	0.0028008974858567235
        0.9325316833444923	0.033734158327753866	0.004481435977370756
        0.9325316833444923	0.05986452500809686	0.0028008974858567235
        0.9869532642585859	0.002757099674531384	0.0004349217053601449
        0.9869532642585859	0.010289636066882744	0.0004349217053601449 ] 
        
    QuadratureRule(
        SVector{65, Point2}([ Point2(pt) for pt in eachrow(mat[:, 1:2]) ]), 
        SVector{65, Float}(mat[:, 3])
        )
end


# Quadrature rule for the case when P is on the element.
const Quad21 = glt7x3( Quad7 ) 

include( "gausslegendre_mod.jl" ) ;

# Generador de reglas de cuadratura de : n * n puntos
macro quad_gquts(n::Int64)
    return quote
        $(quad_gquts(n))
    end
end

function quad_gquts(n::Int64)
    @assert n >= 2

    NodosGauss, W = gausslegendre( n ) ;
    NroPoints = n * n ; # puntos de la regla
    Eta = NodosGauss ;
    Xi = NodosGauss ;
    p = Array{Float64}( undef, NroPoints ) ;
    q = Array{Float64}( undef, NroPoints ) ;
    G = Array{Float64}( undef, NroPoints ) ;
    for j = 1 : n
        for i = 1 : n
#				u[i + (j-1)*n] = ( 1 + Xi[i] )/ 2 ;
#				v[i + (j-1)*n] = ( 1 - Xi[i] ) * ( 1 + Eta[j] ) / 4 ;
#				G[i + (j-1)*n] = ( 1 - Xi[i] ) / 8 * W[i] * W[j] ;
            p[i + (j-1)*n] = ( 1 + Xi[i] ) * ( 1 - Eta[j] ) / 4 ;
            q[i + (j-1)*n] = ( 1 + Eta[j] ) / 2 ;
            G[i + (j-1)*n] = ( 1 - Eta[j] ) / 8 * W[i] * W[j] ;
        end
    end

    return QuadratureRule(
        SVector{NroPoints, Point2}([ Point2((pp, qq)) for (pp, qq) in zip(p, q) ]), 
        SVector{NroPoints, Float}(2G)
    )
end




# Generador de reglas de cuadratura de : n*(n+1)/2 - 1 puntos 
function quad_gqutm( n::Int64 )
    @assert n >= 2

    NroPoints = Int64( n * ( n + 1 ) / 2 - 1 ) ; # puntos de la regla
    p = Array{Float64}( undef, NroPoints ) ;
    q = Array{Float64}( undef, NroPoints ) ;
    G = Array{Float64}( undef, NroPoints ) ;
    r = 1 ;
    for j = 1 : (n-1)
        Eta, Wj = gausslegendre( n - 1 ) ; # Para j
        Xi, Wi = gausslegendre( n + 1 - j ) ; # Para i
        for i = 1 : n + 1 - j
            G[ r ] = ( 1 - Eta[j] ) / 8 * Wi[i] * Wj[j] ;
            q[ r ] = ( 1 + Xi[i] ) * ( 1 - Eta[j] ) / 4 ;
            p[ r ] = ( 1 + Eta[j] ) / 2 ;
            r += 1 ;
        end
    end

    return QuadratureRule(
        SVector{NroPoints, Point2}([ Point2((pp, qq)) for (pp, qq) in zip(p, q) ]), 
        SVector{NroPoints, Float}(2G)
        )
end

macro quad_gqutm(n::Int64)
    return quote
        $(quad_gqutm(n))
    end
end


const quad_default = Quad7
function integrate_triangle(integrand::Function, m::AbstractMesh; quad=quad_default)
    sum(integrate_triangle(integrand, face; quad) for face in m)
end
function integrate_triangle(integrand::Function, tr; quad=quad_default)

    points, weights = adapt(quad, tr)

    res = sum(zip(points, weights)) do ptw
        pt, w = ptw
        integrand(pt)*w
    end  

    return res
end

function adapt(q::QuadratureRule, tr) 
    #=
    los puntos (0,0), (0, 1) y (1, 0) se remapean a los vértices de `triang`
    Esa misma transformación se aplica a los `q.points`. Los pesos se adaptan todos.
    Es una transformación afín. Primero desplazo al centro, y luego transformación lineal.
    =#
    
    offset = tr[1]
    #=   
    La matriz que transforma el (1, 0) en tr.points[2]-tr.points[1] es la que lo tiene
    como primera columna. Idem 2da
    =#
    edge1, edge2 = tr[2]-tr[1], tr[3]-tr[1]
    new_weights = q.weights .* norm(cross(edge1, edge2))/2
    
    new_pts = map(q.points) do pt
        pt[1]*edge1+pt[2]*edge2 + offset
    end 

    (new_pts, new_weights)
end

end # module
